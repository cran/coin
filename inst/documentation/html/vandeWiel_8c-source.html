<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>coin: vandeWiel.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a></div>
<h1>vandeWiel.c</h1><a href="vandeWiel_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00015 <span class="preprocessor">#include &lt;R.h&gt;</span>
00016 <span class="preprocessor">#include &lt;Rmath.h&gt;</span>
00017 <span class="preprocessor">#include &lt;Rdefines.h&gt;</span>
00018                     
00019 
<a name="l00031"></a><a class="code" href="structcelW.html">00031</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00032"></a><a class="code" href="structcelW.html#o0">00032</a>     <span class="keywordtype">long</span> length;
<a name="l00033"></a><a class="code" href="structcelW.html#o1">00033</a>     <span class="keywordtype">double</span> *c;
<a name="l00034"></a><a class="code" href="structcelW.html#o2">00034</a>     <span class="keywordtype">double</span> *x;
00035 } <a class="code" href="structcelW.html">celW</a>;
00036 
<a name="l00037"></a><a class="code" href="vandeWiel_8c.html#a0">00037</a> <span class="keywordtype">double</span> <a class="code" href="vandeWiel_8c.html#a0">binomi</a>(<span class="keywordtype">int</span> m, <span class="keywordtype">int</span> n) { 
00038 
00039     <span class="keywordtype">double</span> bin = 1;
00040     <span class="keywordtype">double</span> bin1 = 1;
00041     <span class="keywordtype">double</span> bin2 = 1;
00042     <span class="keywordtype">int</span> i, j;
00043         
00044     <span class="keywordflow">for</span> (i = 1; i &lt;= n; i++) bin1 = bin1 * (m + 1 -i);
00045     <span class="keywordflow">for</span> (j = 1; j &lt;= n; j++) bin2 = bin2 * j;
00046     bin = bin1/bin2;
00047     
00048     <span class="keywordflow">return</span>(bin);
00049 }
00050 
<a name="l00051"></a><a class="code" href="vandeWiel_8c.html#a1">00051</a> <a class="code" href="structcelW.html">celW</a>** <a class="code" href="vandeWiel_8c.html#a1">reserveW</a>(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b)
00052 {
00053     <span class="keywordtype">long</span> res = 0;
00054     <span class="keywordtype">int</span> i, j;
00055     <a class="code" href="structcelW.html">celW</a>** W;
00056     
00057     <span class="comment">/* &lt;FIXME&gt;: need to free memory in case Calloc barfs</span>
00058 <span class="comment">       Writing R Extension advertises .on.exit but</span>
00059 <span class="comment">       I still need a pointer to the memory.</span>
00060 <span class="comment">       &lt;/FIXME&gt;</span>
00061 <span class="comment">    */</span>
00062 
00063     W = Calloc(a + 1, <a class="code" href="structcelW.html">celW</a>*);
00064 
00065     <span class="keywordflow">for</span> (i = 0; i &lt;= a; i++)
00066         W[i] = Calloc(b + 1, <a class="code" href="structcelW.html">celW</a>);
00067         
00068     <span class="keywordflow">for</span> (i = 0; i &lt;= a; i++) {
00069         <span class="keywordflow">for</span> (j = i; j &lt;= b; j++) {
00070             res = (long) <a class="code" href="vandeWiel_8c.html#a0">binomi</a>(j,i);
00071             <span class="comment">/* the majority of memory is freed on exit and error</span>
00072 <span class="comment">               thanks to S_alloc */</span>
00073             W[i][j].<a class="code" href="structcelW.html#o1">c</a> = (<span class="keywordtype">double</span> *) S_alloc(res, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00074             W[i][j].<a class="code" href="structcelW.html#o2">x</a> = (<span class="keywordtype">double</span> *) S_alloc(res, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00075         }
00076         R_CheckUserInterrupt();
00077     }
00078     <span class="keywordflow">return</span>(W);
00079 }
00080 
<a name="l00081"></a><a class="code" href="vandeWiel_8c.html#a2">00081</a> <span class="keywordtype">void</span> <a class="code" href="vandeWiel_8c.html#a2">FreeW</a>(<span class="keywordtype">int</span> a, <a class="code" href="structcelW.html">celW</a> **W)
00082 {
00083      <span class="keywordtype">int</span> i;
00084  
00085      <span class="keywordflow">for</span> (i = a; i &gt;= 0; i--)
00086          Free(W[i]);
00087          
00088      Free(W);
00089 }
00090 
<a name="l00091"></a><a class="code" href="vandeWiel_8c.html#a3">00091</a> <span class="keywordtype">void</span> <a class="code" href="vandeWiel_8c.html#a3">initW</a>(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b, <a class="code" href="structcelW.html">celW</a> **W) {
00092 
00093     <span class="keywordtype">int</span> i, j;
00094 
00095     <span class="keywordflow">for</span> (i = 1; i &lt;= a; i++)
00096     <span class="keywordflow">for</span> (j = 0; j &lt;= b; j++) {
00097         W[i][j].<a class="code" href="structcelW.html#o0">length</a> = 0;
00098     }
00099     <span class="keywordflow">for</span> (j = 0; j &lt;= b; j++) {
00100         W[0][j].<a class="code" href="structcelW.html#o0">length</a> = 1;
00101         W[0][j].<a class="code" href="structcelW.html#o1">c</a>[0] = 1;  
00102         W[0][j].<a class="code" href="structcelW.html#o2">x</a>[0] = 0;  
00103     }
00104 }
00105 
<a name="l00106"></a><a class="code" href="vandeWiel_8c.html#a4">00106</a> <span class="keywordtype">void</span> <a class="code" href="vandeWiel_8c.html#a4">mult</a>(<a class="code" href="structcelW.html">celW</a> *tem, <span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b, <span class="keywordtype">int</span> rank, <span class="keywordtype">double</span> *rs) {
00107 
00108     <span class="comment">/*</span>
00109 <span class="comment"></span>
00110 <span class="comment">    mult multiplies the polynomial c_i*x^(l_i) by x^(rs[rank]), </span>
00111 <span class="comment">    which means adding the exponents</span>
00112 <span class="comment"></span>
00113 <span class="comment">    */</span>
00114 
00115     <span class="keywordtype">int</span> j;
00116     <span class="keywordflow">for</span> (j = 0; j &lt; tem[0].length; j++)
00117         tem[0].<a class="code" href="structcelW.html#o2">x</a>[j] += rs[rank];
00118 }
00119 
<a name="l00120"></a><a class="code" href="vandeWiel_8c.html#a5">00120</a> <span class="keywordtype">void</span> <a class="code" href="vandeWiel_8c.html#a5">plus</a>(<a class="code" href="structcelW.html">celW</a> **W, <a class="code" href="structcelW.html">celW</a> *tempie, <span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {
00121 
00122     <span class="comment">/*</span>
00123 <span class="comment"></span>
00124 <span class="comment">    plus adds terms with the same exponents after multiplication </span>
00125 <span class="comment">    with 1 + x^(rs[rank]), so c1*x^j + c2*x^j becomes (c1+c2)*x^j</span>
00126 <span class="comment"></span>
00127 <span class="comment">    */</span>
00128 
00129     <span class="keywordtype">int</span> elep = 0;
00130     <span class="keywordtype">int</span> k = 0;
00131     <span class="keywordtype">int</span> test = 1;
00132     <span class="keywordtype">int</span> i, j;
00133     
00134     <span class="keywordflow">for</span> (i = 0; i &lt; W[a][b-1].length; i++) {
00135 
00136         test = 1;
00137         
00138         <span class="keywordflow">for</span> (j = elep; j &lt; tempie[0].length &amp;&amp; test==1; j++) {
00139         
00140             <span class="keywordflow">if</span> (tempie[0].x[j] - 0.000001 &lt;= W[a][b-1].x[i]
00141                 &amp;&amp; W[a][b-1].x[i] &lt;= tempie[0].x[j] + 0.000001) {
00142 
00143                 tempie[0].<a class="code" href="structcelW.html#o1">c</a>[j] += W[a][b-1].<a class="code" href="structcelW.html#o1">c</a>[i];
00144                 test = 0;
00145                 elep = j;             
00146             }
00147         }
00148          
00149         <span class="keywordflow">if</span> (test == 1) {
00150             tempie[0].<a class="code" href="structcelW.html#o1">c</a>[tempie[0].<a class="code" href="structcelW.html#o0">length</a> + k] = W[a][b-1].<a class="code" href="structcelW.html#o1">c</a>[i];
00151             tempie[0].<a class="code" href="structcelW.html#o2">x</a>[tempie[0].<a class="code" href="structcelW.html#o0">length</a> + k] = W[a][b-1].<a class="code" href="structcelW.html#o2">x</a>[i];
00152             k++;
00153         }
00154         R_CheckUserInterrupt();
00155     }
00156     tempie[0].<a class="code" href="structcelW.html#o0">length</a> += k;
00157 }
00158 
<a name="l00159"></a><a class="code" href="vandeWiel_8c.html#a6">00159</a> <span class="keywordtype">void</span> <a class="code" href="vandeWiel_8c.html#a6">mymergesort</a>(<a class="code" href="structcelW.html">celW</a> temptw, <span class="keywordtype">long</span> tijd)
00160 {
00161 
00162     <span class="comment">/*</span>
00163 <span class="comment">    </span>
00164 <span class="comment">    mymergesort composes one sorted list (increasing exponents of </span>
00165 <span class="comment">    the polynomial) from two separately sorted lists. c1*x^3 + c2*x^5 </span>
00166 <span class="comment">    and  c3*x^4 + c4*x^7  becomes  c1*x^3 + c3*x^4 + c2*x^5 + c4*x^7.</span>
00167 <span class="comment"></span>
00168 <span class="comment">    */</span>
00169 
00170     <a class="code" href="structcelW.html">celW</a> copiep;
00171     <span class="keywordtype">int</span> t1 = 0; 
00172     <span class="keywordtype">int</span> t2 = 0;
00173     <span class="keywordtype">int</span> i, j;
00174 
00175     copiep.<a class="code" href="structcelW.html#o1">c</a> = Calloc(temptw.<a class="code" href="structcelW.html#o0">length</a>, <span class="keywordtype">double</span>);
00176     copiep.<a class="code" href="structcelW.html#o2">x</a> = Calloc(temptw.<a class="code" href="structcelW.html#o0">length</a>, <span class="keywordtype">double</span>);
00177         
00178     <span class="keywordflow">for</span> (i = 0; i &lt; temptw.<a class="code" href="structcelW.html#o0">length</a>; i++) {
00179         copiep.<a class="code" href="structcelW.html#o1">c</a>[i] = temptw.<a class="code" href="structcelW.html#o1">c</a>[i];
00180         copiep.<a class="code" href="structcelW.html#o2">x</a>[i] = temptw.<a class="code" href="structcelW.html#o2">x</a>[i];
00181     }
00182     
00183     <span class="keywordflow">for</span> (j = 0; j &lt; temptw.<a class="code" href="structcelW.html#o0">length</a>; j++) {
00184         <span class="keywordflow">if</span> (t1 &lt;= tijd-1 &amp;&amp; t2 &lt;= temptw.<a class="code" href="structcelW.html#o0">length</a> - tijd - 1) {
00185             <span class="keywordflow">if</span> (copiep.<a class="code" href="structcelW.html#o2">x</a>[t1] &lt; copiep.<a class="code" href="structcelW.html#o2">x</a>[tijd + t2]) {
00186                 temptw.<a class="code" href="structcelW.html#o2">x</a>[j] = copiep.<a class="code" href="structcelW.html#o2">x</a>[t1];
00187                 temptw.<a class="code" href="structcelW.html#o1">c</a>[j] = copiep.<a class="code" href="structcelW.html#o1">c</a>[t1];
00188                 t1++;
00189             } <span class="keywordflow">else</span> {
00190                 temptw.<a class="code" href="structcelW.html#o2">x</a>[j] = copiep.<a class="code" href="structcelW.html#o2">x</a>[tijd + t2];
00191                 temptw.<a class="code" href="structcelW.html#o1">c</a>[j] = copiep.<a class="code" href="structcelW.html#o1">c</a>[tijd + t2];
00192                 t2++;
00193             }
00194         } <span class="keywordflow">else</span> {
00195             <span class="keywordflow">if</span> (t1 &gt; tijd - 1) {
00196                 temptw.<a class="code" href="structcelW.html#o2">x</a>[j] = copiep.<a class="code" href="structcelW.html#o2">x</a>[tijd + t2];
00197                 temptw.<a class="code" href="structcelW.html#o1">c</a>[j] = copiep.<a class="code" href="structcelW.html#o1">c</a>[tijd + t2];
00198                 t2++; 
00199             } <span class="keywordflow">else</span> {   
00200                 temptw.<a class="code" href="structcelW.html#o2">x</a>[j] = copiep.<a class="code" href="structcelW.html#o2">x</a>[t1];
00201                 temptw.<a class="code" href="structcelW.html#o1">c</a>[j] = copiep.<a class="code" href="structcelW.html#o1">c</a>[t1];
00202                 t1++;
00203             }
00204         }   
00205         R_CheckUserInterrupt();       
00206     } 
00207     Free(copiep.<a class="code" href="structcelW.html#o1">c</a>);
00208     Free(copiep.<a class="code" href="structcelW.html#o2">x</a>);
00209 }
00210 
<a name="l00211"></a><a class="code" href="vandeWiel_8c.html#a7">00211</a> <span class="keywordtype">void</span> <a class="code" href="vandeWiel_8c.html#a7">fillcell</a>(<a class="code" href="structcelW.html">celW</a> **W, <span class="keywordtype">int</span> i1, <span class="keywordtype">int</span> j1, <span class="keywordtype">int</span> r, <span class="keywordtype">double</span> *rs) {
00212     
00213     <span class="comment">/*</span>
00214 <span class="comment"></span>
00215 <span class="comment">    fillcell makes the new recursive polynomial W[i1][j1] from </span>
00216 <span class="comment">    W[i1 - 1][j1 - 1] and W[i1][j1 - 1]. j1 is the total number of </span>
00217 <span class="comment">    rank scores assigned so far to either of the two groups, </span>
00218 <span class="comment">    i1 is the number of rank scores assigned to the smallest sample.</span>
00219 <span class="comment"></span>
00220 <span class="comment">    */</span>
00221 
00222     <span class="keywordtype">long</span> tijd;
00223     <a class="code" href="structcelW.html">celW</a> temp2;
00224     <span class="keywordtype">int</span> j, j2;
00225 
00226     temp2.<a class="code" href="structcelW.html#o1">c</a> = Calloc(W[i1 - 1][j1 - 1].length + 
00227                      W[i1][j1 - 1].length, <span class="keywordtype">double</span>);
00228     temp2.<a class="code" href="structcelW.html#o2">x</a> = Calloc(W[i1 - 1][j1 - 1].length + 
00229                      W[i1][j1 - 1].length, <span class="keywordtype">double</span>);
00230     temp2.<a class="code" href="structcelW.html#o0">length</a> = W[i1 - 1][j1 - 1].<a class="code" href="structcelW.html#o0">length</a>;
00231 
00232     <span class="keywordflow">for</span> (j = 0; j &lt; temp2.<a class="code" href="structcelW.html#o0">length</a>; j++) {
00233        temp2.<a class="code" href="structcelW.html#o1">c</a>[j] = W[i1 - 1][j1 - 1].<a class="code" href="structcelW.html#o1">c</a>[j];
00234        temp2.<a class="code" href="structcelW.html#o2">x</a>[j] = W[i1 - 1][j1 - 1].<a class="code" href="structcelW.html#o2">x</a>[j];
00235     }
00236 
00237     <span class="keywordflow">if</span> (i1 == j1) {       
00238         <a class="code" href="vandeWiel_8c.html#a4">mult</a>(&amp;temp2, i1 - 1, j1 - 1, r, rs); 
00239     } <span class="keywordflow">else</span> {           
00240         <a class="code" href="vandeWiel_8c.html#a4">mult</a>(&amp;temp2, i1 - 1, j1 - 1, r, rs);                        
00241         tijd = temp2.<a class="code" href="structcelW.html#o0">length</a>;                                
00242         <a class="code" href="vandeWiel_8c.html#a5">plus</a>(W, &amp;temp2, i1, j1);                            
00243         <a class="code" href="vandeWiel_8c.html#a6">mymergesort</a>(temp2, tijd);                              
00244     }
00245 
00246     W[i1][j1].<a class="code" href="structcelW.html#o0">length</a> = temp2.<a class="code" href="structcelW.html#o0">length</a>;
00247 
00248     <span class="keywordflow">for</span> (j2 = 0; j2 &lt; temp2.<a class="code" href="structcelW.html#o0">length</a>; j2++) {
00249         W[i1][j1].<a class="code" href="structcelW.html#o1">c</a>[j2] = temp2.<a class="code" href="structcelW.html#o1">c</a>[j2];
00250         W[i1][j1].<a class="code" href="structcelW.html#o2">x</a>[j2] = temp2.<a class="code" href="structcelW.html#o2">x</a>[j2];
00251     }          
00252 
00253     Free(temp2.<a class="code" href="structcelW.html#o1">c</a>);
00254     Free(temp2.<a class="code" href="structcelW.html#o2">x</a>);
00255 }
00256 
<a name="l00257"></a><a class="code" href="vandeWiel_8c.html#a8">00257</a> <span class="keywordtype">void</span> <a class="code" href="vandeWiel_8c.html#a8">mirrorW</a>(<a class="code" href="structcelW.html">celW</a> **W,<span class="keywordtype">int</span> ce, <span class="keywordtype">int</span> bep, <span class="keywordtype">int</span> start, <span class="keywordtype">double</span> *rs) {   
00258 
00259     <span class="comment">/* </span>
00260 <span class="comment"></span>
00261 <span class="comment">    mirrorW contains a trick to speed op computations considerably. </span>
00262 <span class="comment">    By symmetry arguments it is easy to find W[i][tot] from W[tot-i][tot]</span>
00263 <span class="comment"></span>
00264 <span class="comment">    */</span>
00265 
00266     <span class="keywordtype">double</span> totsum = 0;
00267     <span class="keywordtype">long</span> len;
00268     <span class="keywordtype">int</span> r, h;
00269     
00270     <span class="keywordflow">for</span> (r = 0; r &lt; bep; r++) totsum += rs[start + r];
00271     
00272     len = W[bep-ce][bep].<a class="code" href="structcelW.html#o0">length</a>;
00273         
00274     <span class="keywordflow">for</span> (h = 0; h &lt; len; h++) {
00275         W[ce][bep].<a class="code" href="structcelW.html#o0">length</a> = W[bep-ce][bep].<a class="code" href="structcelW.html#o0">length</a>;
00276         W[ce][bep].<a class="code" href="structcelW.html#o1">c</a>[len-1-h] = W[bep-ce][bep].<a class="code" href="structcelW.html#o1">c</a>[h];
00277         W[ce][bep].<a class="code" href="structcelW.html#o2">x</a>[len-1-h] = totsum - W[bep-ce][bep].<a class="code" href="structcelW.html#o2">x</a>[h];
00278     }
00279 }
00280 
<a name="l00281"></a><a class="code" href="vandeWiel_8c.html#a9">00281</a> <span class="keywordtype">void</span> <a class="code" href="vandeWiel_8c.html#a9">makeW</a>(<a class="code" href="structcelW.html">celW</a> **W, <span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b, <span class="keywordtype">int</span> start, <span class="keywordtype">double</span> *rs) {
00282 
00283 
00284     <span class="comment">/* </span>
00285 <span class="comment"></span>
00286 <span class="comment">    makeW simply determines whether a new polynomial W[i][j] </span>
00287 <span class="comment">    can be found from mirrorW (if W[j-i][j] is available) or needs </span>
00288 <span class="comment">    to be constructed via multiplication etc.</span>
00289 <span class="comment"></span>
00290 <span class="comment">    */</span>
00291 
00292     <span class="keywordtype">long</span> i,j;
00293     <span class="keywordtype">int</span> rank;
00294     <span class="keywordtype">int</span> hulp;
00295 
00296     <span class="keywordflow">for</span> (j = 1; j &lt;= b; j++) {  <span class="comment">/* verander naar 0!! */</span>
00297 
00298         <span class="keywordflow">if</span> (j &lt; a) {
00299             hulp = j; 
00300         } <span class="keywordflow">else</span> {
00301             hulp = a;
00302         }
00303 
00304         <span class="keywordflow">for</span> (i=1; i &lt;= hulp; i++) {   
00305             <span class="keywordflow">if</span> (i &lt;= j/2 || j == 1) {
00306                 rank = start+j;
00307                 <a class="code" href="vandeWiel_8c.html#a7">fillcell</a>(W, i, j, rank - 1, rs);
00308             } <span class="keywordflow">else</span> {
00309                 <a class="code" href="vandeWiel_8c.html#a8">mirrorW</a>(W, i, j, start, rs);
00310             }                               
00311             R_CheckUserInterrupt();
00312         }
00313     }
00314 }
00315 
<a name="l00316"></a><a class="code" href="vandeWiel_8c.html#a10">00316</a> <span class="keywordtype">void</span> <a class="code" href="vandeWiel_8c.html#a10">cumulcoef</a>(<a class="code" href="structcelW.html">celW</a> **W, <span class="keywordtype">int</span> i1, <span class="keywordtype">int</span> j1) {
00317 
00318 
00319     <span class="comment">/*</span>
00320 <span class="comment"></span>
00321 <span class="comment">    cumulcoef recursively adds the coefficients of the </span>
00322 <span class="comment">    sorted polynomial. So, 3*x^4 + 4*x^6 + 2*x^7  becomes  </span>
00323 <span class="comment">    3*x^4 + 7*x^6 + 9*x^7.  </span>
00324 <span class="comment"></span>
00325 <span class="comment">    */</span>
00326     <span class="keywordtype">double</span> coef = 0;
00327     <span class="keywordtype">int</span> i;
00328      
00329     <span class="keywordflow">for</span>(i = 0; i &lt; W[i1][j1].<a class="code" href="structcelW.html#o0">length</a>; i++) {
00330         W[i1][j1].<a class="code" href="structcelW.html#o1">c</a>[i] += coef;
00331         coef = W[i1][j1].<a class="code" href="structcelW.html#o1">c</a>[i];
00332     }
00333 }
00334 
<a name="l00335"></a><a class="code" href="vandeWiel_8c.html#a11">00335</a> <span class="keywordtype">double</span> <a class="code" href="vandeWiel_8c.html#a11">numbersmall</a>(<span class="keywordtype">int</span> c, <span class="keywordtype">int</span> b, <span class="keywordtype">double</span> ob, <a class="code" href="structcelW.html">celW</a> **W1, <a class="code" href="structcelW.html">celW</a> **W2) {
00336 
00337 
00338     <span class="comment">/*</span>
00339 <span class="comment"></span>
00340 <span class="comment">    numbersmall is the core of the split-up algorithm. </span>
00341 <span class="comment">    </span>
00342 <span class="comment">    It efficiently combines two polynomials which have used </span>
00343 <span class="comment">    complementary sets of rank scores and computes their contribution </span>
00344 <span class="comment">    to the tail-probability. </span>
00345 <span class="comment"></span>
00346 <span class="comment">    */</span>
00347 
00348     <span class="keywordtype">double</span> tot = 0;
00349     <span class="keywordtype">long</span> le;
00350     <span class="keywordtype">int</span> test = 1;
00351     <span class="keywordtype">int</span> be = b/2;
00352     <span class="keywordtype">int</span> bp = (b+1)/2;
00353     <span class="keywordtype">int</span> tempel = 0;
00354     <span class="keywordtype">int</span> i, j, h;
00355     
00356     <span class="keywordflow">for</span> (h = 0; h &lt;= c; h++) {
00357 
00358         tempel = 0;
00359         le = W2[c-h][bp].<a class="code" href="structcelW.html#o0">length</a>;
00360         
00361         <span class="keywordflow">for</span> (i = 0; i &lt; W1[h][be].length; i++) {
00362             test = 1;
00363             <span class="keywordflow">for</span> (j = tempel; j &lt; le &amp;&amp; test == 1; j++) {
00364                 <span class="keywordflow">if</span> (W1[h][be].x[i] + W2[c-h][bp].x[le-j-1] &lt;= ob) {
00365                     tot += W1[h][be].<a class="code" href="structcelW.html#o1">c</a>[i] * W2[c - h][bp].<a class="code" href="structcelW.html#o1">c</a>[le - j -1];
00366                     tempel = j;
00367                     test = 0;
00368                 }
00369             }
00370         }
00371     }
00372     <span class="keywordflow">return</span>(tot);
00373 }
00374        
<a name="l00375"></a><a class="code" href="vandeWiel_8c.html#a12">00375</a> SEXP <a class="code" href="vandeWiel_8c.html#a12">R_split_up_2sample</a>(SEXP scores, SEXP m, SEXP obs) {
00376         
00377     <span class="comment">/*</span>
00378 <span class="comment"></span>
00379 <span class="comment">    R interface to the split-up algorithm. </span>
00380 <span class="comment"></span>
00381 <span class="comment">    `scores' is a REAL vector giving the scores of the total sample </span>
00382 <span class="comment">    and `m' is a scalar integer with the sample size of one group.</span>
00383 <span class="comment">    `obs' is the scalar observed test statistic, namely the</span>
00384 <span class="comment">    sum of the `m' scores measured in one group.</span>
00385 <span class="comment"></span>
00386 <span class="comment">    */</span>
00387 
00388     <span class="keywordtype">int</span> b, c, d, u;
00389     <span class="keywordtype">double</span> tot, bino, prob;
00390     <span class="keywordtype">double</span> ob;  
00391     SEXP ans;
00392 
00393     <a class="code" href="structcelW.html">celW</a> **W1;
00394     <a class="code" href="structcelW.html">celW</a> **W2;
00395     <span class="keywordtype">double</span> *rs;
00396 
00397     b = LENGTH(scores);
00398     rs = REAL(scores);
00399     c = INTEGER(m)[0];
00400     d = b - INTEGER(m)[0];
00401     ob = REAL(obs)[0];
00402 
00403     <span class="comment">/* total number of possible permutations */</span>
00404     bino = <a class="code" href="vandeWiel_8c.html#a0">binomi</a>(b, c);
00405 
00406     <span class="comment">/* allocate and initialise memory */</span>
00407     W1 = <a class="code" href="vandeWiel_8c.html#a1">reserveW</a>(c, (b+1)/2);
00408     <a class="code" href="vandeWiel_8c.html#a3">initW</a>(c, (b+1)/2, W1);
00409     W2 = <a class="code" href="vandeWiel_8c.html#a1">reserveW</a>(c, (b+1)/2);
00410     <a class="code" href="vandeWiel_8c.html#a3">initW</a>(c, (b+1)/2, W2);
00411     
00412     <a class="code" href="vandeWiel_8c.html#a9">makeW</a>(W1, c, b/2, 0, rs);  
00413     <a class="code" href="vandeWiel_8c.html#a9">makeW</a>(W2, c, (b+1)/2, b/2, rs);
00414 
00415     <span class="keywordflow">for</span> (u = 0; u &lt;= c; u++) <a class="code" href="vandeWiel_8c.html#a10">cumulcoef</a>(W2, u, (b+1)/2);
00416 
00417     <span class="comment">/* number of permutations &lt;= ob */</span>
00418     tot = <a class="code" href="vandeWiel_8c.html#a11">numbersmall</a>(c, b, ob, W1, W2);
00419     
00420     <span class="comment">/* probability */</span>
00421     prob = tot/bino; 
00422     
00423     <span class="comment">/* free memory: this will _not_ take place </span>
00424 <span class="comment">       in case of an error */</span>
00425     <a class="code" href="vandeWiel_8c.html#a2">FreeW</a>(c, W1);
00426     <a class="code" href="vandeWiel_8c.html#a2">FreeW</a>(c, W2);
00427 
00428     <span class="comment">/* return to R */</span>
00429     PROTECT(ans = allocVector(REALSXP, 1));
00430     REAL(ans)[0] = prob;
00431     UNPROTECT(1);
00432     <span class="keywordflow">return</span>(ans);
00433 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Jul 28 17:02:21 2005 for coin by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
