<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>coin: CIstuff.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a></div>
<h1>CIstuff.c</h1><a href="CIstuff_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00009 <span class="preprocessor">#include "<a class="code" href="CI__common_8h.html">CI_common.h</a>"</span>
00010 
<a name="l00011"></a><a class="code" href="CIstuff_8h.html#a0">00011</a> <span class="keywordtype">int</span> <a class="code" href="CIstuff_8c.html#a0">nrow</a>(SEXP x) {
00012     SEXP a;
00013 
00014     a = getAttrib(x, R_DimSymbol);
00015     <span class="keywordflow">if</span> (a == R_NilValue) {
00016         <span class="keywordflow">return</span>(LENGTH(x));
00017     } <span class="keywordflow">else</span> {
00018         <span class="keywordflow">return</span>(INTEGER(getAttrib(x, R_DimSymbol))[0]);
00019     }
00020 }
00021     
<a name="l00022"></a><a class="code" href="CIstuff_8h.html#a1">00022</a> <span class="keywordtype">int</span> <a class="code" href="CIstuff_8c.html#a1">ncol</a>(SEXP x) {
00023     SEXP a;
00024     
00025     a = getAttrib(x, R_DimSymbol);
00026     <span class="keywordflow">if</span> (a == R_NilValue) {
00027         <span class="keywordflow">return</span>(1);
00028     } <span class="keywordflow">else</span> {
00029         <span class="keywordflow">return</span>(INTEGER(getAttrib(x, R_DimSymbol))[1]);
00030     }
00031 }
00032         
00033 
<a name="l00042"></a><a class="code" href="CIstuff_8c.html#a2">00042</a> <span class="keywordtype">void</span> <a class="code" href="CIstuff_8c.html#a2">C_SampleNoReplace</a>(<span class="keywordtype">int</span> *x, <span class="keywordtype">int</span> m, <span class="keywordtype">int</span> k, <span class="keywordtype">int</span> *ans) {
00043                          
00044     <span class="keywordtype">int</span> i, j, n = m;
00045 
00046     <span class="keywordflow">for</span> (i = 0; i &lt; m; i++)
00047         x[i] = i;
00048     <span class="keywordflow">for</span> (i = 0; i &lt; k; i++) {
00049         j = n * unif_rand();    
00050         ans[i] = x[j];
00051         x[j] = x[--n];  
00052     }
00053 }
00054 
00055 
<a name="l00056"></a><a class="code" href="CIstuff_8c.html#a3">00056</a> SEXP <a class="code" href="CIstuff_8c.html#a3">R_blocksetup</a> (SEXP block) {
00057 
00058     <span class="keywordtype">int</span> n, nlev, nlevels, i, j, *iblock, l;
00059     SEXP ans, dims, indices, dummies, pindices, lindex;
00060     
00061     n = LENGTH(block);
00062     iblock = INTEGER(block);
00063     nlevels = 1;
00064     <span class="keywordflow">for</span> (i = 0; i &lt; n; i++) {
00065         <span class="keywordflow">if</span> (iblock[i] &gt; nlevels) nlevels++;
00066     }
00067     
00068     PROTECT(ans = allocVector(VECSXP, 4));
00069     SET_VECTOR_ELT(ans, 0, dims = allocVector(INTSXP, 2));
00070     SET_VECTOR_ELT(ans, 1, indices = allocVector(VECSXP, nlevels));
00071     SET_VECTOR_ELT(ans, 2, dummies = allocVector(VECSXP, nlevels));
00072     SET_VECTOR_ELT(ans, 3, pindices = allocVector(VECSXP, nlevels));
00073     
00074     INTEGER(dims)[0] = n;
00075     INTEGER(dims)[1] = nlevels;
00076 
00077     <span class="keywordflow">for</span> (l = 1; l &lt;= nlevels; l++) {
00078     
00079         <span class="comment">/* number of elements in block `l' */</span>
00080         nlev = 0;   
00081         <span class="keywordflow">for</span> (i = 0; i &lt; n; i++) {
00082             <span class="keywordflow">if</span> (iblock[i] == l) nlev++;
00083         }
00084                                                 
00085         <span class="comment">/* which(block == l) and memory setup */</span>
00086         SET_VECTOR_ELT(indices, l - 1, lindex = allocVector(INTSXP, nlev));
00087         SET_VECTOR_ELT(dummies, l - 1, allocVector(INTSXP, nlev));
00088         SET_VECTOR_ELT(pindices, l - 1, allocVector(INTSXP, nlev));
00089 
00090         j = 0;
00091         <span class="keywordflow">for</span> (i = 0; i &lt; n; i++) {   
00092             <span class="keywordflow">if</span> (iblock[i] == l) {
00093                 INTEGER(lindex)[j] = i;
00094                 j++; 
00095             }
00096         }
00097     }
00098 
00099     UNPROTECT(1);
00100     <span class="keywordflow">return</span>(ans);
00101 }
00102 
00103 
<a name="l00110"></a><a class="code" href="CIstuff_8c.html#a4">00110</a> <span class="keywordtype">void</span> <a class="code" href="CIstuff_8c.html#a4">C_blockperm</a> (SEXP blocksetup, <span class="keywordtype">int</span> *ans) {
00111                   
00112     <span class="keywordtype">int</span> n, nlevels, l, nlev, j, *iindex, *ipindex;
00113     SEXP indices, dummies, pindices, index, dummy, pindex;
00114 
00115     n = INTEGER(VECTOR_ELT(blocksetup, 0))[0];
00116     nlevels = INTEGER(VECTOR_ELT(blocksetup, 0))[1];
00117     indices = VECTOR_ELT(blocksetup, 1);
00118     dummies = VECTOR_ELT(blocksetup, 2);
00119     pindices = VECTOR_ELT(blocksetup, 3);
00120     
00121     <span class="keywordflow">for</span> (l = 1; l &lt;= nlevels; l++) {
00122     
00123         <span class="comment">/* number of elements in block `l' */</span>
00124         index = VECTOR_ELT(indices, l - 1);
00125         dummy = VECTOR_ELT(dummies, l - 1);
00126         pindex = VECTOR_ELT(pindices, l - 1);
00127         nlev = LENGTH(index);
00128         iindex = INTEGER(index);
00129         ipindex = INTEGER(pindex);
00130 
00131         <a class="code" href="CIstuff_8c.html#a2">C_SampleNoReplace</a>(INTEGER(dummy), nlev, nlev, ipindex);
00132 
00133         <span class="keywordflow">for</span> (j = 0; j &lt; nlev; j++) {
00134             ans[iindex[j]] = iindex[ipindex[j]];
00135         }
00136     }
00137 }
00138 
<a name="l00139"></a><a class="code" href="CIstuff_8c.html#a5">00139</a> SEXP <a class="code" href="CIstuff_8c.html#a5">R_blockperm</a> (SEXP block) {
00140 
00141     SEXP blocksetup, ans;
00142     
00143     blocksetup = <a class="code" href="CIstuff_8c.html#a3">R_blocksetup</a>(block);
00144     PROTECT(ans = allocVector(INTSXP, LENGTH(block)));
00145     GetRNGstate();
00146     <a class="code" href="CIstuff_8c.html#a4">C_blockperm</a>(blocksetup, INTEGER(ans));
00147     PutRNGstate();
00148     UNPROTECT(1);
00149     <span class="keywordflow">return</span>(ans);
00150 }
00151 
<a name="l00152"></a><a class="code" href="CIstuff_8c.html#a6">00152</a> SEXP <a class="code" href="CIstuff_8c.html#a6">R_MonteCarloIndependenceTest</a> (SEXP x, SEXP y, SEXP block, SEXP B) {
00153 
00154     <span class="keywordtype">int</span> n, p, q, pq, i, *index, *permindex, b, Bsim;
00155     SEXP ans, blocksetup, linstat;
00156     <span class="keywordtype">double</span> *dans, *dlinstat, *dx, *dy, f = 0.1;
00157     
00158     n = <a class="code" href="CIstuff_8c.html#a0">nrow</a>(x);
00159     p = <a class="code" href="CIstuff_8c.html#a1">ncol</a>(x);
00160     q = <a class="code" href="CIstuff_8c.html#a1">ncol</a>(y);
00161     pq = p*q;
00162     Bsim = INTEGER(B)[0];
00163     dx = REAL(x);
00164     dy = REAL(y);
00165     
00166     index = Calloc(n, <span class="keywordtype">int</span>);
00167     permindex = Calloc(n, <span class="keywordtype">int</span>);
00168 
00169     PROTECT(blocksetup = <a class="code" href="CIstuff_8c.html#a3">R_blocksetup</a>(block));
00170 
00171     PROTECT(ans = allocMatrix(REALSXP, pq, Bsim));
00172     dans = REAL(ans);
00173     PROTECT(linstat = allocVector(REALSXP, pq));
00174     dlinstat = REAL(linstat);
00175     
00176     <span class="keywordflow">for</span> (i = 0; i &lt; n; i++)
00177         index[i] = i;
00178         
00179     GetRNGstate();
00180         
00181     <span class="keywordflow">for</span> (b = 0; b &lt; Bsim; b++) {
00182 
00183         <a class="code" href="CIstuff_8c.html#a4">C_blockperm</a>(blocksetup, permindex);
00184         <a class="code" href="LinearStatistic_8c.html#a8">C_PermutedLinearStatistic</a>(dx, p, dy, q, n, n, index, permindex, dlinstat);
00185         
00186         <span class="keywordflow">for</span> (i = 0; i &lt; pq; i++) dans[b*pq + i] = dlinstat[i];
00187         
00188         <span class="comment">/* check user interrupts */</span>
00189         <span class="keywordflow">if</span> (b &gt; Bsim * f) {
00190             R_CheckUserInterrupt();
00191             f += 0.1;
00192         }
00193     }
00194 
00195     PutRNGstate();
00196 
00197     UNPROTECT(3);
00198     <span class="keywordflow">return</span>(ans);
00199 }
00200 
00201 
<a name="l00202"></a><a class="code" href="CIstuff_8c.html#a7">00202</a> SEXP <a class="code" href="CIstuff_8c.html#a7">R_maxstattrafo</a>(SEXP x, SEXP cutpoints) {
00203 
00204     <span class="keywordtype">int</span> i, j, n, nc, jn;
00205     SEXP ans;
00206     <span class="keywordtype">double</span> *dans, *dx, *dcutpoints, cj;
00207     
00208     <span class="keywordflow">if</span> (!isReal(x) || !isReal(cutpoints))
00209         error(<span class="stringliteral">"x or cutpoints are not of type REALSXP"</span>);
00210         
00211     n = LENGTH(x);
00212     nc = LENGTH(cutpoints);
00213     PROTECT(ans = allocMatrix(REALSXP, n, nc));
00214     dans = REAL(ans);
00215     dx = REAL(x);
00216     dcutpoints = REAL(cutpoints);
00217     
00218     <span class="keywordflow">for</span> (j = 0; j &lt; nc; j++) {
00219         jn = j * n;
00220         cj = dcutpoints[j];
00221         <span class="keywordflow">for</span> (i = 0; i &lt; n; i++) {
00222             <span class="keywordflow">if</span> (dx[i] &gt; cj) {
00223                 dans[jn + i] = 0.0;
00224             } <span class="keywordflow">else</span> {
00225                 dans[jn + i] = 1.0;
00226             }
00227         }
00228     }
00229     UNPROTECT(1);
00230     <span class="keywordflow">return</span>(ans);
00231 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Nov 17 15:36:17 2005 for coin by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
